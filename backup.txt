import java.io.PrintWriter;
import java.io.FileWriter;
import java.io.IOException;
import java.sql.*;
import java.util.ArrayList;

public class Stage1 {

	public static void main(String[] args) throws SQLException, IOException {

		FileWriter writer = new FileWriter("CommonComplaints.txt", false);
		PrintWriter printer = new PrintWriter(writer);

		Connection con = DriverManager.getConnection("jdbc:mysql://127.0.0.1/sys", "root", "matt");
		Statement s = con.createStatement();
		System.out.print("Determining most common complaint makes... ");

		// Run query to count most common makes in complaint database
		ResultSet makeCount = s.executeQuery(
				"select distinct MAKETXT, count(*) from flat_cmpl group by MAKETXT ORDER BY count(*) DESC");

		// Add most commmon 1% of makes to common complaint database
		int count = 0;
		int cap = (int) (0.01 * getRowCount(makeCount));
		ArrayList<Complaint> complaints = new ArrayList<Complaint>();
		while (count < cap) {
			Complaint complaint = new Complaint(makeCount.getString(1).toString());
			complaints.add(complaint);
			count++;
			makeCount.next();
		}

		System.out.print("done\n");

		// find the top 3 most common component complaints for each make
		System.out.print("Determining most common complaint components... ");

		for (Complaint complaint : complaints) {
			ResultSet compCount = s.executeQuery("select distinct COMPDESC, count(*) from flat_cmpl WHERE MAKETXT = '"
					+ complaint.make + "' group by COMPDESC ORDER BY count(*) DESC");
			compCount.first();
			complaint.setComp1(compCount.getString(1).toString());
			compCount.next();
			complaint.setComp2(compCount.getString(1).toString());
			compCount.next();
			complaint.setComp3(compCount.getString(1).toString());
		}

		System.out.print("done\n");

		String filter = "";
		boolean first = true;
		for (Complaint complaint : complaints) {
			if (first) {
				filter += "(MAKETXT = '" + complaint.make + "' && (COMPDESC = '" + complaint.comp1 + "' || COMPDESC = '"
						+ complaint.comp2 + "' || COMPDESC = '" + complaint.comp3 + "'))";
				first = false;
			} else
				filter += " || (MAKETXT = '" + complaint.make + "' && (COMPDESC = '" + complaint.comp1
						+ "' || COMPDESC = '" + complaint.comp2 + "' || COMPDESC = '" + complaint.comp3 + "'))";
		}

		System.out.print("Determining most common complaints... ");

		ResultSet common = s.executeQuery("SELECT * FROM flat_cmpl WHERE " + filter + " ORDER BY YEARTXT ASC");

		count = 1;
		cap = getRowCount(common);
		while (count <= cap) {
			printer.println(common.getString(6) + "," + common.getString(4) + "," + common.getString(5) + ","
					+ common.getString(12) + "," + common.getString(7) + "," + common.getString(9) + ","
					+ common.getString(10) + "," + common.getString(11) + ",\"" + common.getString(20).replace(",","") + "\", ,");
			count++;
			common.next();
		}

		System.out.print("done\n");
		System.out.println("Results printed to file \"CommonComplaints.txt\"");
		printer.close();
	}

	/**
	 * returns the number of rows in ResultSet
	 */
	public static int getRowCount(ResultSet rs) throws SQLException {
		try {
			rs.last();
			int rows = rs.getRow();
			rs.first();
			return rows;
		} catch (SQLException e) {
			e.printStackTrace();
			return 0;
		}
	}

}









import java.io.PrintWriter;
import java.io.FileWriter;
import java.io.IOException;
import java.sql.*;

public class TrainingSetGenerator {

	public static void main(String[] args) throws IOException, SQLException {
		FileWriter writer = new FileWriter("TrainingSet.txt", false);
		PrintWriter printer = new PrintWriter(writer);

		FileWriter writer2 = new FileWriter("RecallSet.txt", false);
		PrintWriter printer2 = new PrintWriter(writer2);
		
		Connection con = DriverManager.getConnection("jdbc:mysql://127.0.0.1/sys", "root", "matt");
		Statement s = con.createStatement();
		
		System.out.print("Generating training set...");

		// Run query to count most common makes in complaint database
		ResultSet rs = s.executeQuery(
				"select * from flat_cmpl where MAKETXT = 'Honda' or MAKETXT = 'Toyota' or MAKETXT = 'Nissan' or MAKETXT = 'Subaru' or MAKETXT = 'Mitsubishi'");

		int count = 1;
		int cap = getRowCount(rs);
		while (count <= cap) {
			printer.println(rs.getString(6) + "," + rs.getString(4) + "," + rs.getString(5) + ","
					+ rs.getString(12).split(":|\\,")[0] + "," + rs.getString(7) + "," + rs.getString(9) + ","
					+ rs.getString(10) + "," + rs.getString(11) + ",\"" + rs.getString(20).replace(",","") + "\", ,");
			count++;
			rs.next();
		}
		
		System.out.print(" done\n");
		printer.close();
		
		rs = s.executeQuery("select * from flat_rcl");
		//printer2.println(rs.getString);
	}
	
	/**
	 * returns the number of rows in ResultSet
	 */
	public static int getRowCount(ResultSet rs) throws SQLException {
		try {
			rs.last();
			int rows = rs.getRow();
			rs.first();
			return rows;
		} catch (SQLException e) {
			e.printStackTrace();
			return 0;
		}
	}

}









import net.sf.javaml.classification.Classifier;
import net.sf.javaml.classification.KNearestNeighbors;
import net.sf.javaml.core.Dataset;
import net.sf.javaml.core.Instance;
import net.sf.javaml.tools.data.FileHandler;
import java.io.File;
import java.io.IOException;

public class Stage2 {

	public static void main(String[] args) throws IOException {
		
		/* Load a data set */
		Dataset data = FileHandler.loadDataset(new File("RecallSet.txt"), 5, ",");
		
		/*
		 * Construct a KNN classifier that uses 10 neighbors to make a decision.
		 */
		Classifier knn = new KNearestNeighbors(100);
		knn.buildClassifier(data);

		Dataset dataForClassification = FileHandler.loadDataset(new File("RecallSet.txt"), 5, ",");
		
		/* Counters for correct and wrong predictions. */
		//int correct = 0, wrong = 0;
		
		/* Classify all instances and check with the correct class values */
		for (Instance inst : dataForClassification) {
			Object predictedClassValue = knn.classify(inst);
			Object realClassValue = inst.classValue();
			System.out.println("Real: " + realClassValue + " Predicted: " + predictedClassValue);
			if (predictedClassValue != null)
				System.out.println(predictedClassValue.toString());
		}

		//System.out.println("Score: " + correct + "/" + (correct + wrong));
	}
}

